<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HeartConnect Ultimate - æ‹æ„›ç³»è³ªå•ã‚«ãƒ¼ãƒ‰ã‚¢ãƒ—ãƒª</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/background.css">
    <link rel="stylesheet" href="css/components.css">
    <link rel="stylesheet" href="css/buttons.css">
    <link rel="stylesheet" href="css/animations.css">
    <link rel="stylesheet" href="css/effects.css">
</head>
<body>
    <!-- Background -->
    <div class="background-container">
        <div class="background-image"></div>
        <div class="background-overlay"></div>
    </div>

    <!-- Enhanced Touch Effect System -->
    <canvas id="touchEffectCanvas" class="touch-effect-canvas"></canvas>
    <div class="particle-system" id="particleSystem"></div>
    <div class="heart-burst-container" id="heartBurstContainer"></div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Start Screen -->
        <div id="startScreen" class="screen active">
            <div class="start-content">
                <div class="app-logo">
                    <h1 class="app-title">HeartConnect</h1>
                    <p class="app-subtitle">Ultimate</p>
                </div>
                <p class="app-description">
                    é©æ–°çš„ãªè‡ªå·±é–‹ç¤ºãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§<br>
                    çœŸã®ä¿¡é ¼é–¢ä¿‚ã‚’ç§‘å­¦çš„ã«æ§‹ç¯‰ã™ã‚‹
                </p>
                
                <div class="mode-selection">
                    <button class="mode-btn normal-mode" onclick="startDirectMode('normal')">
                        <div class="mode-icon">ğŸ’</div>
                        <div class="mode-text">ãƒãƒ¼ãƒãƒ«ãƒ¢ãƒ¼ãƒ‰</div>
                        <div class="mode-desc">æ—¥å¸¸çš„ãªè³ªå•ã§é–¢ä¿‚ã‚’æ·±ã‚ã‚‹</div>
                    </button>
                    
                    <button class="mode-btn unique-mode" onclick="startDirectMode('unique')">
                        <div class="mode-icon">âœ¨</div>
                        <div class="mode-text">ãƒ¦ãƒ‹ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰</div>
                        <div class="mode-desc">å‰µé€ çš„ãªè³ªå•ã§æ–°ã—ã„ç™ºè¦‹ã‚’</div>
                    </button>
                    
                    <button class="mode-btn shadow-mode" onclick="startDirectMode('shadow')">
                        <div class="mode-icon">ğŸ”¥</div>
                        <div class="mode-text">SHADOW MODE</div>
                        <div class="mode-desc">å¤§äººå‘ã‘ã®åˆºæ¿€çš„ãªè³ªå•</div>
                    </button>
                    
                    <button class="mode-btn chaos-mode" onclick="startDirectMode('chaos')">
                        <div class="mode-icon">âš¡</div>
                        <div class="mode-text">CHAOS MODE</div>
                        <div class="mode-desc">ç©¶æ¥µã®è‡ªå·±é–‹ç¤ºãƒ»é­‚ã®æ·±å±¤</div>
                    </button>
                </div>
            </div>
        </div>

        <!-- Password screens removed - direct access enabled -->

        <!-- Level Selection Screen -->
        <div id="levelScreen" class="screen">
            <div class="level-content">
                <div class="screen-header">
                    <button class="nav-btn back" onclick="backToStart()">â† æˆ»ã‚‹</button>
                    <h2 class="screen-title">ãƒ¬ãƒ™ãƒ«é¸æŠ</h2>
                    <div class="mode-indicator" id="modeIndicator">ãƒãƒ¼ãƒãƒ«ãƒ¢ãƒ¼ãƒ‰</div>
                </div>
                
                <div class="level-grid" id="levelGrid">
                    <!-- ãƒ¬ãƒ™ãƒ«ãƒœã‚¿ãƒ³ãŒJSã§å‹•çš„ç”Ÿæˆã•ã‚Œã‚‹ -->
                </div>
            </div>
        </div>

        <!-- Main Game Screen -->
        <div id="gameScreen" class="screen">
            <div class="game-content">
                <div class="game-header">
                    <button class="nav-btn home" onclick="backToStart()">ğŸ </button>
                    <div class="progress-info">
                        <div class="level-badge" id="currentLevel">Level 1</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                    </div>
                </div>
                
                <div class="question-container">
                    <div class="question-card" id="questionCard">
                        <div class="question-number" id="questionNumber">1/10</div>
                        <div class="question-text" id="questionText"></div>
                        
                        <div class="answer-examples" id="answerExamples">
                            <!-- å›ç­”ä¾‹ãŒJSã§å‹•çš„ç”Ÿæˆã•ã‚Œã‚‹ -->
                        </div>
                        
                        <div class="reaction-buttons">
                            <button class="reaction-btn" onclick="react('empathy')" data-reaction="empathy">
                                ğŸ’– å…±æ„Ÿï¼
                            </button>
                            <button class="reaction-btn" onclick="react('curious')" data-reaction="curious">
                                ğŸ¤” è©³ã—ãçŸ¥ã‚ŠãŸã„
                            </button>
                            <button class="reaction-btn" onclick="react('more')" data-reaction="more">
                                ğŸ’­ ã‚‚ã£ã¨èã‹ã›ã¦
                            </button>
                            <button class="reaction-btn" onclick="react('question')" data-reaction="question">
                                â“ è³ªå•ã—ãŸã„
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="navigation-buttons">
                    <button class="nav-btn prev" onclick="previousQuestion()" id="prevBtn">
                        â† å‰ã®è³ªå•
                    </button>
                    <button class="nav-btn level-select" onclick="backToLevelSelect()">
                        ğŸ“‹ ãƒ¬ãƒ™ãƒ«é¸æŠ
                    </button>
                    <button class="nav-btn next" onclick="nextQuestion()" id="nextBtn">
                        æ¬¡ã®è³ªå• â†’
                    </button>
                </div>
            </div>
        </div>

        <!-- Completion Screen -->
        <div id="completionScreen" class="screen">
            <div class="completion-content">
                <div class="completion-header">
                    <h2>ğŸ‰ ãƒ¬ãƒ™ãƒ«å®Œäº†ï¼ ğŸ‰</h2>
                    <div class="completion-stats" id="completionStats"></div>
                </div>
                
                <div class="completion-buttons">
                    <button class="completion-btn continue" onclick="continueToNextLevel()">
                        æ¬¡ã®ãƒ¬ãƒ™ãƒ«ã¸
                    </button>
                    <button class="completion-btn restart" onclick="restartLevel()">
                        ã“ã®ãƒ¬ãƒ™ãƒ«ã‚’ã‚‚ã†ä¸€åº¦
                    </button>
                    <button class="completion-btn home" onclick="backToStart()">
                        ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript -->
    <script src="js/config.js"></script>
    <script src="js/questions.js"></script>
    <script>
        // Global State
        let currentMode = 'normal';
        let currentLevel = 1;
        let currentQuestionIndex = 0;
        let shadowModeUnlocked = true; // å¸¸ã«ã‚¢ãƒ³ãƒ­ãƒƒã‚¯
        let chaosModeUnlocked = true; // å¸¸ã«ã‚¢ãƒ³ãƒ­ãƒƒã‚¯
        let shadowModeCompleted = false;
        let gameState = {
            reactions: 0,
            trustLevel: 0,
            completedLevels: new Set()
        };

        // Enhanced Touch Effect System
        class HeartConnectTouchEffects {
            constructor() {
                this.canvas = document.getElementById('touchEffectCanvas');
                if (!this.canvas) {
                    console.warn('Touch effect canvas not found');
                    return;
                }
                
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.touchPoints = [];
                this.animationId = null;
                this.activeTouches = new Map();
                this.lastTouchPositions = new Map();
                this.knownTouchIds = new Set();
                
                // Heart images
                this.heartImages = [];
                this.imageLoaded = false;
                this.loadHeartImages();
                
                this.init();
                this.bindEvents();
                this.animate();
            }
            
            loadHeartImages() {
                const img1 = new Image();
                img1.onload = () => {
                    this.heartImages[0] = img1;
                    this.checkImageLoad();
                };
                img1.src = 'image/1.png';
                
                const img2 = new Image();
                img2.onload = () => {
                    this.heartImages[1] = img2;
                    this.checkImageLoad();
                };
                img2.src = 'image/2.png';
            }
            
            checkImageLoad() {
                if (this.heartImages.length === 2) {
                    this.imageLoaded = true;
                    console.log('âœ… HeartConnectç”»åƒèª­ã¿è¾¼ã¿å®Œäº†');
                }
            }
            
            init() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            bindEvents() {
                // ãƒãƒ«ãƒã‚¿ãƒƒãƒå®Œå…¨å¯¾å¿œ
                document.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: true });
                document.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: true });
                document.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: true });
                document.addEventListener('touchcancel', (e) => this.handleTouchEnd(e), { passive: true });
                
                document.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                document.addEventListener('mouseup', (e) => this.handleMouseUp(e));
            }
            
            handleTouchStart(e) {
                Array.from(e.touches).forEach(touch => {
                    if (!this.knownTouchIds.has(touch.identifier)) {
                        this.knownTouchIds.add(touch.identifier);
                        
                        const touchData = {
                            x: touch.clientX,
                            y: touch.clientY,
                            startTime: Date.now(),
                            lastTime: Date.now()
                        };
                        
                        this.activeTouches.set(touch.identifier, touchData);
                        this.lastTouchPositions.set(touch.identifier, { x: touch.clientX, y: touch.clientY });
                        
                        this.createHeartBurst(touch.clientX, touch.clientY);
                        this.addTouchPoint(touch.clientX, touch.clientY);
                        
                        // ãƒã‚¤ãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                        if (navigator.vibrate) {
                            navigator.vibrate(25);
                        }
                    }
                });
            }
            
            handleTouchMove(e) {
                Array.from(e.touches).forEach(touch => {
                    if (!this.knownTouchIds.has(touch.identifier)) {
                        this.knownTouchIds.add(touch.identifier);
                        
                        const touchData = {
                            x: touch.clientX,
                            y: touch.clientY,
                            startTime: Date.now(),
                            lastTime: Date.now()
                        };
                        
                        this.activeTouches.set(touch.identifier, touchData);
                        this.lastTouchPositions.set(touch.identifier, { x: touch.clientX, y: touch.clientY });
                        
                        this.createHeartBurst(touch.clientX, touch.clientY);
                    }
                    
                    if (this.activeTouches.has(touch.identifier)) {
                        const lastPos = this.lastTouchPositions.get(touch.identifier);
                        const currentPos = { x: touch.clientX, y: touch.clientY };
                        
                        const distance = Math.sqrt(
                            Math.pow(currentPos.x - lastPos.x, 2) + 
                            Math.pow(currentPos.y - lastPos.y, 2)
                        );
                        
                        if (distance > 15) {
                            this.createHeartTrail(currentPos.x, currentPos.y);
                        }
                        
                        this.addTouchPoint(currentPos.x, currentPos.y);
                        this.lastTouchPositions.set(touch.identifier, currentPos);
                        
                        const touchData = this.activeTouches.get(touch.identifier);
                        touchData.x = currentPos.x;
                        touchData.y = currentPos.y;
                        touchData.lastTime = Date.now();
                    }
                });
            }
            
            handleTouchEnd(e) {
                Array.from(e.changedTouches).forEach(touch => {
                    if (this.activeTouches.has(touch.identifier)) {
                        this.createHeartFinale(touch.clientX, touch.clientY);
                        this.activeTouches.delete(touch.identifier);
                        this.lastTouchPositions.delete(touch.identifier);
                        this.knownTouchIds.delete(touch.identifier);
                    }
                });
                
                if (this.activeTouches.size === 0) {
                    setTimeout(() => {
                        this.touchPoints = [];
                    }, 200);
                }
            }
            
            handleMouseDown(e) {
                if (!this.activeTouches.has('mouse')) {
                    this.activeTouches.set('mouse', {
                        x: e.clientX,
                        y: e.clientY,
                        startTime: Date.now(),
                        lastTime: Date.now()
                    });
                    this.lastTouchPositions.set('mouse', { x: e.clientX, y: e.clientY });
                    this.createHeartBurst(e.clientX, e.clientY);
                    this.addTouchPoint(e.clientX, e.clientY);
                }
            }
            
            handleMouseMove(e) {
                if (this.activeTouches.has('mouse')) {
                    const lastPos = this.lastTouchPositions.get('mouse');
                    const currentPos = { x: e.clientX, y: e.clientY };
                    
                    const distance = Math.sqrt(
                        Math.pow(currentPos.x - lastPos.x, 2) + 
                        Math.pow(currentPos.y - lastPos.y, 2)
                    );
                    
                    if (distance > 12) {
                        this.createHeartTrail(currentPos.x, currentPos.y);
                    }
                    
                    this.addTouchPoint(currentPos.x, currentPos.y);
                    this.lastTouchPositions.set('mouse', currentPos);
                }
            }
            
            handleMouseUp(e) {
                if (this.activeTouches.has('mouse')) {
                    this.createHeartFinale(e.clientX, e.clientY);
                    this.activeTouches.delete('mouse');
                    this.lastTouchPositions.delete('mouse');
                    setTimeout(() => {
                        this.touchPoints = [];
                    }, 200);
                }
            }
            
            addTouchPoint(x, y) {
                this.touchPoints.push({
                    x: x,
                    y: y,
                    time: Date.now()
                });
                
                this.touchPoints = this.touchPoints.filter(point => 
                    Date.now() - point.time < 300
                );
            }
            
            createHeartBurst(x, y) {
                const particleCount = currentMode === 'chaos' ? 10 : 6;
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const speed = Math.random() * 3 + 2;
                    const useImage = this.imageLoaded && Math.random() < 0.6;
                    
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: Math.random() * 3 + 2,
                        life: 1,
                        decay: 0.02,
                        color: this.getHeartColor(),
                        type: useImage ? 'image' : 'heart',
                        rotation: 0,
                        rotationSpeed: (Math.random() - 0.5) * 0.3,
                        imageIndex: currentLevel <= 5 ? 0 : 1
                    });
                }
            }
            
            createHeartTrail(x, y) {
                for (let i = 0; i < 2; i++) {
                    const offsetX = (Math.random() - 0.5) * 20;
                    const offsetY = (Math.random() - 0.5) * 20;
                    const useImage = this.imageLoaded && Math.random() < 0.4;
                    
                    this.particles.push({
                        x: x + offsetX,
                        y: y + offsetY,
                        vx: (Math.random() - 0.5) * 1.5,
                        vy: -(Math.random() * 1.5 + 0.5),
                        size: Math.random() * 2 + 1,
                        life: 1,
                        decay: 0.03,
                        color: this.getHeartColor(),
                        type: useImage ? 'image' : 'trail',
                        rotation: 0,
                        rotationSpeed: (Math.random() - 0.5) * 0.2,
                        imageIndex: currentLevel <= 5 ? 0 : 1
                    });
                }
            }
            
            createHeartFinale(x, y) {
                const particleCount = currentMode === 'chaos' ? 12 : 8;
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const speed = Math.random() * 4 + 2.5;
                    const useImage = this.imageLoaded && Math.random() < 0.7;
                    
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: Math.random() * 4 + 2,
                        life: 1,
                        decay: 0.015,
                        color: this.getHeartColor(),
                        type: useImage ? 'image' : 'finale',
                        rotation: 0,
                        rotationSpeed: (Math.random() - 0.5) * 0.4,
                        imageIndex: currentLevel <= 5 ? 0 : 1,
                        glow: true
                    });
                }
            }
            
            getHeartColor() {
                if (currentMode === 'chaos') {
                    const chaosColors = [
                        'rgba(138, 43, 226, 0.8)',
                        'rgba(255, 20, 147, 0.8)',
                        'rgba(255, 69, 0, 0.8)',
                        'rgba(50, 205, 50, 0.8)',
                        'rgba(255, 215, 0, 0.8)'
                    ];
                    return chaosColors[Math.floor(Math.random() * chaosColors.length)];
                } else {
                    const level = currentLevel || 1;
                    const levelColors = [
                        'rgba(255, 182, 193, 0.8)', // Light Pink
                        'rgba(255, 105, 180, 0.8)', // Hot Pink  
                        'rgba(255, 20, 147, 0.8)',  // Deep Pink
                        'rgba(199, 21, 133, 0.8)',  // Medium Violet Red
                        'rgba(139, 0, 0, 0.8)'      // Dark Red
                    ];
                    const colorIndex = Math.min(Math.floor((level - 1) / 2), levelColors.length - 1);
                    return levelColors[colorIndex];
                }
            }
            
            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life -= particle.decay;
                    particle.rotation += particle.rotationSpeed;
                    
                    particle.vy += 0.02; // gravity
                    particle.vx *= 0.998;
                    particle.vy *= 0.998;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            drawParticles() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.particles.forEach(particle => {
                    this.ctx.save();
                    
                    this.ctx.globalAlpha = particle.life * 0.9;
                    this.ctx.translate(particle.x, particle.y);
                    this.ctx.rotate(particle.rotation);
                    
                    if (particle.type === 'image' && this.imageLoaded && this.heartImages[particle.imageIndex]) {
                        // Heart image drawing
                        const img = this.heartImages[particle.imageIndex];
                        const size = particle.size * 8;
                        
                        if (currentMode === 'chaos') {
                            this.ctx.shadowColor = particle.color;
                            this.ctx.shadowBlur = 8;
                            this.ctx.filter = `hue-rotate(${Math.random() * 360}deg) saturate(1.5)`;
                        } else {
                            this.ctx.shadowColor = particle.color;
                            this.ctx.shadowBlur = 4;
                        }
                        
                        this.ctx.drawImage(img, -size/2, -size/2, size, size);
                    } else {
                        // Heart shape drawing
                        this.ctx.fillStyle = particle.color;
                        this.ctx.shadowColor = particle.color;
                        this.ctx.shadowBlur = particle.glow ? 8 : 4;
                        
                        this.drawHeart(0, 0, particle.size);
                    }
                    
                    this.ctx.restore();
                });
            }
            
            drawHeart(x, y, size) {
                this.ctx.beginPath();
                this.ctx.moveTo(x, y + size/4);
                this.ctx.bezierCurveTo(x, y, x - size/2, y, x - size/2, y + size/4);
                this.ctx.bezierCurveTo(x - size/2, y + size/2, x, y + size, x, y + size);
                this.ctx.bezierCurveTo(x, y + size, x + size/2, y + size/2, x + size/2, y + size/4);
                this.ctx.bezierCurveTo(x + size/2, y, x, y, x, y + size/4);
                this.ctx.fill();
            }
            
            animate() {
                this.updateParticles();
                this.drawParticles();
                this.animationId = requestAnimationFrame(() => this.animate());
            }
            
            destroy() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }
        }

        // Initialize App
        function init() {
            // Initialize new touch effect system
            window.touchEffects = new HeartConnectTouchEffects();
            
            createParticleSystem();
            updateDisplay();
            
            // Enhanced touch feedback with precise event handling
            if ('vibrate' in navigator) {
                document.addEventListener('touchstart', (e) => {
                    navigator.vibrate(10);
                }, { passive: true });
            }
        }

        // Direct Mode Start (1ã‚¿ãƒƒãƒ—ã‚¢ã‚¯ã‚»ã‚¹)
        function startDirectMode(mode) {
            currentMode = mode;
            showScreen('levelScreen');
            generateLevelGrid();
            
            // CHAOSãƒ¢ãƒ¼ãƒ‰é¸æŠæ™‚ã«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            if (mode === 'chaos') {
                triggerChaosUnlockEffect();
            }
        }

        // Legacy Mode Selection (äº’æ›æ€§ã®ãŸã‚ä¿æŒ)
        function selectMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.closest('.mode-btn').classList.add('active');
            document.querySelector('.start-btn').disabled = false;
        }

        // Shadow and CHAOS modes are now always available

        function triggerChaosUnlockEffect() {
            // Create intense screen flash effect
            const flash = document.createElement('div');
            flash.className = 'chaos-unlock-flash';
            flash.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: radial-gradient(circle, 
                    rgba(138, 43, 226, 0.9) 0%, 
                    rgba(255, 20, 147, 0.8) 30%,
                    rgba(255, 69, 0, 0.7) 60%,
                    transparent 100%);
                z-index: 20000;
                animation: chaosFlash 1.5s ease-out forwards;
                pointer-events: none;
            `;
            
            document.body.appendChild(flash);
            
            // Enhanced haptic feedback
            if (navigator.vibrate) {
                navigator.vibrate([100, 50, 100, 50, 200]);
            }
            
            setTimeout(() => {
                if (flash.parentNode) {
                    flash.parentNode.removeChild(flash);
                }
            }, 1500);
        }

        // Navigation
        function startApp() {
            if (currentMode) {
                showScreen('levelScreen');
                generateLevelGrid();
            }
        }

        function backToStart() {
            showScreen('startScreen');
            resetGame();
        }

        function backToLevelSelect() {
            showScreen('levelScreen');
        }

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
        }

        // Level Selection
        function generateLevelGrid() {
            const grid = document.getElementById('levelGrid');
            const modeIndicator = document.getElementById('modeIndicator');
            
            const modeNames = {
                'normal': 'ãƒãƒ¼ãƒãƒ«ãƒ¢ãƒ¼ãƒ‰',
                'unique': 'ãƒ¦ãƒ‹ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰',
                'shadow': 'SHADOW MODE',
                'chaos': 'CHAOS MODE'
            };
            
            modeIndicator.textContent = modeNames[currentMode];
            modeIndicator.className = `mode-indicator ${currentMode}`;
            
            grid.innerHTML = '';
            
            for (let level = 1; level <= 9; level++) {
                const levelBtn = document.createElement('button');
                levelBtn.className = `level-btn ${currentMode}`;
                levelBtn.onclick = () => selectLevel(level);
                
                levelBtn.innerHTML = `
                    <div class="level-number">LEVEL ${level}</div>
                    <div class="level-description">${getLevelDescription(level)}</div>
                    <div class="level-questions">${getQuestionCount(level)} questions</div>
                `;
                
                grid.appendChild(levelBtn);
            }
        }

        function getLevelDescription(level) {
            const descriptions = {
                1: 'è»½ã„è©±é¡Œ', 2: 'æ—¥å¸¸ã®è©±', 3: 'æ„Ÿæƒ…ã«ã¤ã„ã¦',
                4: 'é–¢ä¿‚æ€§', 5: 'ç§˜å¯†ã¨æœ¬éŸ³', 6: 'è¦ªå¯†ã•',
                7: 'ç¦æ–­ã®è©±é¡Œ', 8: 'åˆºæ¿€çš„ãªä½“é¨“', 9: 'ç©¶æ¥µã®è³ªå•'
            };
            return descriptions[level] || '';
        }

        function getQuestionCount(level) {
            return QUESTIONS[currentMode] && QUESTIONS[currentMode][level] ? 
                   QUESTIONS[currentMode][level].length : 0;
        }

        function selectLevel(level) {
            currentLevel = level;
            currentQuestionIndex = 0;
            showScreen('gameScreen');
            updateGameDisplay();
        }

        // Game Logic
        function updateGameDisplay() {
            const questions = QUESTIONS[currentMode][currentLevel];
            if (!questions || questions.length === 0) return;
            
            const questionText = questions[currentQuestionIndex];
            document.getElementById('questionText').textContent = questionText;
            document.getElementById('currentLevel').textContent = `Level ${currentLevel}`;
            document.getElementById('questionNumber').textContent = 
                `${currentQuestionIndex + 1}/${questions.length}`;
            
            updateProgressBar();
            updateAnswerExamples();
            updateNavigationButtons();
            
            // Add click event listener to question card for manual burst effect
            const questionCard = document.getElementById('questionCard');
            if (questionCard) {
                questionCard.onclick = function(e) {
                    // ã‚¯ãƒªãƒƒã‚¯å¯èƒ½è¦ç´ ã§ã‚‚ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ä½¿ç”¨
                    const rect = questionCard.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    createGlobalHeartBurst(centerX, centerY);
                };
            }
        }

        function updateProgressBar() {
            const questions = QUESTIONS[currentMode][currentLevel];
            const progress = ((currentQuestionIndex + 1) / questions.length) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
        }

        function updateAnswerExamples() {
            const container = document.getElementById('answerExamples');
            container.innerHTML = '<h4>ğŸ’¡ å›ç­”ä¾‹</h4>';
            
            // ç°¡å˜ãªå›ç­”ä¾‹ã‚’è¡¨ç¤º
            const examples = [
                'æ­£ç›´ã«ç­”ãˆã‚‹',
                'ä½“é¨“è«‡ã‚’è©±ã™',
                'æ„Ÿæƒ…ã‚’ä¼ãˆã‚‹',
                'è³ªå•ã§è¿”ã™'
            ];
            
            examples.forEach(example => {
                const div = document.createElement('div');
                div.className = 'example-item';
                div.textContent = example;
                div.onclick = () => selectExample(div);
                container.appendChild(div);
            });
        }

        function updateNavigationButtons() {
            const questions = QUESTIONS[currentMode][currentLevel];
            document.getElementById('prevBtn').disabled = currentQuestionIndex === 0;
            document.getElementById('nextBtn').textContent = 
                currentQuestionIndex === questions.length - 1 ? 'ãƒ¬ãƒ™ãƒ«å®Œäº†' : 'æ¬¡ã®è³ªå• â†’';
        }

        // Question Navigation
        function nextQuestion() {
            const questions = QUESTIONS[currentMode][currentLevel];
            
            if (currentQuestionIndex < questions.length - 1) {
                currentQuestionIndex++;
                updateGameDisplay();
            } else {
                // Level completed
                gameState.completedLevels.add(currentLevel);
                showLevelCompletion();
            }
        }

        function previousQuestion() {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                updateGameDisplay();
            }
        }

        // Reactions
        function react(type) {
            gameState.reactions++;
            gameState.trustLevel += 5;
            
            createReactionEffect(type);
            
            const messages = {
                empathy: 'å…±æ„Ÿã—ã¦ãã‚Œã¦ã‚ã‚ŠãŒã¨ã†ï¼ğŸ’•',
                curious: 'ã‚‚ã£ã¨è©³ã—ãèã‹ã›ã¦ã­ï¼ğŸ¤”',
                more: 'ç¶šããŒæ°—ã«ãªã‚‹ï¼ğŸ’­',
                question: 'è³ªå•ãŒã‚ã‚‹ã‚“ã ã­ï¼â“'
            };
            
            showMessage(messages[type]);
        }

        function createReactionEffect(type) {
            const btn = event.target;
            btn.classList.add('reacting');
            setTimeout(() => btn.classList.remove('reacting'), 300);
        }

        // Simplified global burst for backward compatibility
        function createGlobalHeartBurst(x, y) {
            if (window.touchEffects) {
                window.touchEffects.createHeartBurst(x, y);
            }
        }

        // Legacy heart burst for clickable elements
        function createHeartBurst(event) {
            if (window.touchEffects) {
                let x, y;
                if (event.touches && event.touches.length > 0) {
                    x = event.touches[0].clientX;
                    y = event.touches[0].clientY;
                } else {
                    x = event.clientX || event.pageX;
                    y = event.clientY || event.pageY;
                }
                window.touchEffects.createHeartBurst(x, y);
            }
        }

        // CHAOS Mode Upward Flow Effect - now simplified
        function createChaosUpwardFlow(centerX, centerY) {
            // This is now handled by the HeartConnectTouchEffects class
            if (window.touchEffects && currentMode === 'chaos') {
                window.touchEffects.createHeartFinale(centerX, centerY);
            }
        }

        // Particle System
        function createParticleSystem() {
            const container = document.getElementById('particleSystem');
            
            setInterval(() => {
                if (Math.random() < 0.3) {
                    const particle = document.createElement('div');
                    particle.className = 'floating-particle';
                    
                    // Different particles for different levels
                    if (currentLevel <= 2) {
                        particle.innerHTML = 'â­';
                    } else {
                        particle.innerHTML = 'ğŸ’';
                    }
                    
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.animationDuration = (3 + Math.random() * 2) + 's';
                    
                    container.appendChild(particle);
                    
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.parentNode.removeChild(particle);
                        }
                    }, 5000);
                }
            }, 2000);
        }

        // Utility Functions
        function selectExample(element) {
            element.classList.add('selected');
            setTimeout(() => element.classList.remove('selected'), 1000);
        }

        function showMessage(text) {
            const message = document.createElement('div');
            message.className = 'message-popup';
            message.textContent = text;
            document.body.appendChild(message);
            
            setTimeout(() => {
                if (message.parentNode) {
                    message.parentNode.removeChild(message);
                }
            }, 2500);
        }

        function showLevelCompletion() {
            document.getElementById('completionStats').innerHTML = `
                <div class="stat">ãƒ¬ãƒ™ãƒ« ${currentLevel} å®Œäº†ï¼</div>
                <div class="stat">ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ•°: ${gameState.reactions}</div>
                <div class="stat">ä¿¡é ¼åº¦: ${gameState.trustLevel}%</div>
            `;
            showScreen('completionScreen');
        }

        function continueToNextLevel() {
            if (currentLevel < 9) {
                currentLevel++;
                currentQuestionIndex = 0;
                showScreen('gameScreen');
                updateGameDisplay();
            } else {
                showFinalCompletion();
            }
        }

        function restartLevel() {
            currentQuestionIndex = 0;
            showScreen('gameScreen');
            updateGameDisplay();
        }

        function resetGame() {
            currentLevel = 1;
            currentQuestionIndex = 0;
            gameState = {
                reactions: 0,
                trustLevel: 0,
                completedLevels: new Set()
            };
        }

        function updateDisplay() {
            // Update level colors and effects based on current level
            document.body.className = `level-${currentLevel} mode-${currentMode}`;
        }

        function showFinalCompletion() {
            showMessage('ğŸŠ å…¨ãƒ¬ãƒ™ãƒ«å®Œäº†ï¼ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼ ğŸŠ');
            setTimeout(() => backToStart(), 3000);
        }

        // These functions are now handled by HeartConnectTouchEffects class
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>